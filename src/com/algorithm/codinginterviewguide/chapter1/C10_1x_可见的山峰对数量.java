package com.algorithm.codinginterviewguide.chapter1;


import java.util.LinkedList;

/**
 * 题目:
 *     一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度。
 *     比如，{3,1,2,4,5} {4,5,3,1,2} {1,2,4,5,3} 都代表同样结构的环形山
 *     3-1-2-4-5-3 方向叫做next方向（逆时针）， 3-5-4-2-1-3方向叫做last方向（顺时针），
 *     如图所示：
 *          Codeing interview guide
 *          图 1-8
 *
 *     山峰A 和 山峰B 能够相互看见的条件为：
 *       1. 如果A 和 B是同一座山， 认为不能相互看见。
 *       2. 如果A 和 B是不同的山，并且在环中相邻，认为可以相互看见。比如图1-8中， 相邻的山峰对有（1，2）（2，4）（4，5）（3，5）（1，3）
 *       3. 如果A 和 B是不同的山，并且在环中不相邻， 假设两座山高度的最小值为min.
 *             如果A通过next方向到B的途中没有高度比min大的山峰， 或者A通过last方向到B的途中没有高度比min大的山峰，
 *             认为A和B可以相互看见。
 *             比如图1-8中，高度为3的山和高度为4的山，两座山的高度最小值为3. 3从last方向走向4，中途会遇到5，所以last方向走不通；
 *             3从next方向走向4，中途会遇到1和2，但是都不大于两座山高度的最小值3，所以next方向可以走通。
 *             有一个能走通就认为可以相互看见，再如，高度为2的山和高度为5的山，两个方向上都走不通，所以不能相互看见。
 *             图1-8中，所有在环中不相邻，并且能看见的山峰对有（2，3）（3，4）
 *
 *     给定一个不含有负数且没有重复值的数组arr, 请返回有多少山峰能够相互看见。
 *
 *
 *  进阶问题：
 *      给定一个不含有负数但可能含有重复值的数组arr, 返回有多少山峰能够相互看见。
 *
 *
 *       要求：
 *          如果arr长度为N, 没有重复值的情况下时间复杂度达到O(1), 可能有重复值的情况下时间复杂度达到O(N)
 *
 */
public class C10_1x_可见的山峰对数量 {


    /**
     * 解法:
     *    原问题： 时间复杂度O（1）解法, 如果数组中所有的数字都不一样，可见山峰的数量可以由简单公式得到。
     *    1座山峰： 可见山峰对数0
     *    2座山峰： 可见山峰对数1
     *    i>2时： 可见山峰对数 2*i -3
     *  证明：
     *     用高度小的山峰找高度大的山峰，从每一个位置出发， 都按照”小找大“原则找到山峰对的数量，就是总的可见山峰对数量。
     *     如果由i座山峰并且高度都不一样，必然在环中存在唯一的最大值和唯一的次大值。如图1-9
     *
     *     图 1-9 中，x节点表示除最高值之外的任何一座山峰。因为x即不是最大值，也不是次大值，所以x在last方向上必存在
     *     第一个高度比它大的节点，假设这个节点是y, y有可能就是最大值节点，但是一定存在。
     *     x在next方向上必存在一个高度比它大的节点，假设这个大的节点是z, z有可能就是次大值节点，但是一定存在.
     *     因为y时x在last方向上第一个高度比它大的节点，所以x在last方向上没有到达y之前遇到的所有山峰高度都小于x,不符合”小找大“。
     *     同理，x在next方向上没有到达z之前遇到的所有山峰高度都小于x,不符合”小找大“。
     *     同时根据可见山峰对的定义，y从last方向到达z这一段的每一个节点x都看不见。所以从x 出发能找到且只能找到（x,y)(x,z)这2对。
     *     如果环中有i个节点，除了最大值和次大值之外，还剩i-2个节点，这i-2个节点都根据”小找大“,每一个能找到2对。
     *     所以一共有 （i-2) * 2 对，还有一对就是次大值能够看到最大值， 一共 2*i - 3对。
     *
     */


    /**
     * 进阶问题：
     *      时间复杂度为 O(N)的解法。
     *      还是按照”小找大“的方式来解， 并利用”单调栈结构“。 举例说明，假设环形山
     *                     如图 1-10：
     *          首先遍历一次环形山结构， 找到最大值的位置， 如果最大值不止一个， 找哪一个最大值都行，比如图1-10 中5是最大值且不止一个，
     *      找哪一个都行，我们选最下方的5， 准备一个栈，记为stack<Rocord> ,stack放入的是如下数据结构：
     *           class Record
     *
     *      接下来从最大值开始沿着 next方向在遍历一遍环形山，stack中先放入 [5,1], 表示5这个高度，收集一个。 以后放入记录时，
     *      都保证第一维的数字从顶到底依次增大。 目前stack从顶到底为[5,1]
     *          沿着next方向来到4， 生成记录[4, 1], 表示4这个数，收集1个， 发现如果这个记录加入stack, 第一维的数字从顶到底时
     *      依次增大的， 所以放入[4,1],
     *
     *
     *
     * @param args
     */

    public static void main(String[] args) {

    }


}

class Record {
    public int value;
    public int times;

    public Record(int value) {
        this.value = value;
        this.times = 1;
    }
}
