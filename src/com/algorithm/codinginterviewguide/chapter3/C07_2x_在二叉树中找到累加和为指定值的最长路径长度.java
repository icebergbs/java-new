package com.algorithm.codinginterviewguide.chapter3;

/**
 *
 * 题目：
 *      给定一棵二叉树的头节点head和一个32位整数sum,二叉树节点值类型为整型，求累加
 *      和为sum的最长路径长度。路径是指从某个节点往下，每次最多选择一个孩子节点或者不选
 *      所形成的节点链。
 *      例如，二叉树如图3-16所示。
 *      如果sum = 6, 那么累加和为6的最长路径为：-3，3，0，6， 所以返回4
 *      如果sum = -9, 那么累加和为-9的最长路径为：-9，所以返回1。
 *      注：本题不用考虑节点值相加可能溢出的情况。
 *
 *
 * @author bingshan
 * @date 2022/12/25 20:21
 */
public class C07_2x_在二叉树中找到累加和为指定值的最长路径长度 {

/*
    在解答本题之前，请读者先阅读本书”求未排序数组中累加和为规定值的最长子数组长度“问题。
    针对二叉树，本文的解法改写了这个问题的实现。如果二叉树的节点树为N,本题的解法可以做的时间复杂度为O(N),
额外空间复杂度为O(h),h为二叉树的高度。
    具体过程如下：
    1. 二叉树头节点head和规定值sum已知：生产变量maxLen, 负责记录累加和等于sum的最长路径长度。
    2. 生成哈希表sumMap。 在”求未排序数组中累加和为规定值的最长子数组长度“问题中也使用了哈希表，
       功能是记录数组从左到右的累加和出现情况，在变量数组的过程中，再利用这个哈希表来求得累加和为规定
       值的最长子数组。sumMap也一样，它负责记录从head开始的一条路径上的累加和出现情况，累加和也是从
       head节点的值开始累加的。sumMap的key值代表某个累加和，value值代表这个累加和在路径中最早出现的层数。
       如果在遍历到cur节点的时候，我们能够知道从head到cur节点这条路径上的累加和出现情况，那么求以cur节点
       结尾的累加和为指定值的最长路径长度就非常容易。究竟如何去更新sumMap,才能够做到在遍历到任何一个节点
       的时候都有从head到这个节点的路径上的累加和出现情况呢？ 步骤3 详细地说明了更新过程。
    3. 首先在sumMap中加入一个记录（0，0），他表示累加和0不用包括任何节点就可以得到。
       然后按照二叉树先序遍历的方式遍历节点，遍历到的当前节点记为cur, 从head到cur父节点的累加和记为preSum,
       cur所在的层数记为level。将cur.value + preSum的值记为curSum, 就是从head到cur的累加和。
       如果sumMap中已经包含了curSum的记录，说明curSum在上层中已经出现过，那么就不更新sumMap;
       如果sumMap不包含curSum的记录，说明curSum是第一次出现，就把（curSum.level)这个记录放入sumMap。
       接下来是求解在必须以cur结尾的情况下，累加和为规定值的最长路径长度，详细过程这里不再详设，请读者阅读
       "求为排序数组中累加和为规定值的最长子数组长度“问题。然后是遍历cur左子树和右子树的过程，依然按照步骤3描述
       的使用和更新sumMap。以cur为头节点的子查询curSum这个累加和（key)出现的层数（value),如果value等于level,
       说明curSum这个累加和的记录是在遍历到cur时加上去的，那就把这一条记录删除；如果value等于level，则不做任何调整。
    4. 步骤3会遍历二叉树的所有节点，也会求解以每个节点结尾的情况下，累加和为规定值的最长路径长度。用maxLen记录其中的最大值即可。


 */
}
