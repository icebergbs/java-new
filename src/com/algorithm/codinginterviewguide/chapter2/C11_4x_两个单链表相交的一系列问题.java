package com.algorithm.codinginterviewguide.chapter2;

/**
 * 题目:
 *      在本题中,单链表可能有环,也可能无环.给定两个单链表的头节点head1 和 head2,
 *      这两个链表可能相交,也可能不相交.
 *      请实现一个函数, 如果两个链表相交,请返回相交的第一个节点; 如果不相交,返回null
 *
 *  要求:
 *     如果链表1的长度为N, 链表2的长度为M, 时间复杂度请到达O(N+M), 额外空间复杂度请达到O(1)
 *
 *
 */
public class C11_4x_两个单链表相交的一系列问题 {

    class Node {
        public int value;
        public Node next;
        public Node rand;

        public Node(int data) {
            this.value = data;
        }
    }

/*
  这道题需要分析的情况非常多，因为要求的额外空间复杂度为O(1),所以实现起来比较困难。
  本题可以拆分成3个子问题，每一个问题都可以作为一道独立的算法题。
  问题一： 如何判断一个链表是否有环，如果有，则返回第一个进入环的节点，没有则返回null.
  问题二： 如何判断两个有环链表是否相交，相交则返回第一个相交节点，不相交则返回null.
  问题三： 如何判断两个有环链表是否相交，相交则返回第一个相交节点，不相交则返回null.
  注意：如果一个链表有环，另一个链表无环，它们是不可能相交的，直接返回null.

 */

/*
  问题一： 如何判断一个链表是否有环，如果有，则返回第一个进入环的节点，没有则返回null.
  如果一个链表没有环，那么遍历链表一定可以遇到链表的终点。; 如果链表有环，那么遍历链表就
永远在环里转下去，如何找到第一个入环的节点，具体过程如下：
  1. 设置一个慢指针slow和一个块指针fast. 在开始时，slow和fast都指向链表的头节点head.
然后slow每移动一步，fast每次移动两步，在链表中遍历。
  2. 如果链表无环，那么fast指针在移动过程中一定先遇到终点，一旦fast到达终点，说明链表是
没有环的，直接返回null,表示该链表无环，当然也没有第一个入环节点。
  3. 如果链表有环，那么fast指针和slow指针一定会在环中的某个位置相遇，当fast和slow相遇时，
fast指针重新回到head的位置，slow指针不动。 接下来，fast指针从每次移动两步改为每次移动一步，
slow指针依然每次移动一步，然后继续遍历。
  4.
  
 */

}
